
/* ============================
   ZENITH V1 — GRAMMAR
===============================
- Lines start with /
- /tag opens
- /tag/ closes
- Text must be in "quotes"
- Attributes use key:value
- Complex values use key:"value"
- Boolean attributes allowed
- Styles are shortcuts:
  font weight color align size
- CSS NEVER appears in HTML
=============================== */


/* ============================
   ZENITH V1 — DICTIONARY
=============================== */

const DICTIONARY = {
  // document
  zen: { type: "doctype" },
  html: { type: "block", tag: "html" },
  head: { type: "block", tag: "head" },
  body: { type: "block", tag: "body" },
  title: { type: "block", tag: "title" },
  meta: { type: "self", tag: "meta" },
  link: { type: "self", tag: "link" },
  script: { type: "block", tag: "script" },
  style: { type: "block", tag: "style" },

  // sectioning
  header: { type: "block", tag: "header" },
  nav: { type: "block", tag: "nav" },
  main: { type: "block", tag: "main" },
  section: { type: "block", tag: "section" },
  article: { type: "block", tag: "article" },
  aside: { type: "block", tag: "aside" },
  footer: { type: "block", tag: "footer" },

  // text
  h1: { type: "block", tag: "h1" },
  h2: { type: "block", tag: "h2" },
  h3: { type: "block", tag: "h3" },
  h4: { type: "block", tag: "h4" },
  h5: { type: "block", tag: "h5" },
  h6: { type: "block", tag: "h6" },
  p: { type: "block", tag: "p" },
  span: { type: "inline", tag: "span" },
  strong: { type: "inline", tag: "strong" },
  em: { type: "inline", tag: "em" },
  small: { type: "inline", tag: "small" },

  // lists
  ul: { type: "block", tag: "ul" },
  ol: { type: "block", tag: "ol" },
  li: { type: "block", tag: "li" },

  // media
  img: { type: "self", tag: "img" },
  video: { type: "block", tag: "video" },
  audio: { type: "block", tag: "audio" },
  source: { type: "self", tag: "source" },

  // tables
  table: { type: "block", tag: "table" },
  thead: { type: "block", tag: "thead" },
  tbody: { type: "block", tag: "tbody" },
  tr: { type: "block", tag: "tr" },
  th: { type: "block", tag: "th" },
  td: { type: "block", tag: "td" },

  // forms
  form: { type: "block", tag: "form" },
  input: { type: "self", tag: "input" },
  textarea: { type: "block", tag: "textarea" },
  button: { type: "block", tag: "button" },
  label: { type: "block", tag: "label" },
  select: { type: "block", tag: "select" },
  option: { type: "block", tag: "option" },

  // misc
  div: { type: "block", tag: "div" },
  a: { type: "block", tag: "a" },
  iframe: { type: "block", tag: "iframe" },
  br: { type: "self", tag: "br" },
  hr: { type: "self", tag: "hr" }
};


/* ============================
   ZENITH V1 — COMPILER
=============================== */

let lastHTML = "";
let lastCSS = "";

function compileZenith() {
  const input = zenInput.value.split("\n");

  let html = [];
  let css = [];
  let stack = [];
  let classId = 0;

  for (let raw of input) {
    const line = raw.trim();
    if (!line) continue;

    // DOCTYPE
    if (line === "/zen") {
      html.push("<!DOCTYPE html>");
      continue;
    }

    // CLOSE BLOCK
    if (line.endsWith("/")) {
      const name = line.slice(1, -1);
      const entry = DICTIONARY[name];
      if (entry) {
        html.push(`</${entry.tag}>`);
        stack.pop();
      }
      continue;
    }

    if (!line.startsWith("/")) continue;

    const parts = line.slice(1).match(/(?:[^\s"]+|"[^"]*")+/g);
    const name = parts.shift();
    const entry = DICTIONARY[name];
    if (!entry) continue;

    let text = "";
    let attrs = [];
    let styles = [];

    for (let p of parts) {
      if (p.startsWith("\"")) {
        text = p.slice(1, -1);
      } else if (p.includes(":")) {
        const [k, vRaw] = p.split(":");
        const v = vRaw.replace(/"/g, "");
        if (["color", "align", "size", "weight", "font"].includes(k)) {
          styles.push([k, v]);
        } else {
          attrs.push(`${k}="${v}"`);
        }
      } else {
        attrs.push(p);
      }
    }

    let className = "";
    if (styles.length) {
      className = `z-${++classId}`;
      let rules = [];
      for (let [k, v] of styles) {
        if (k === "align") rules.push(`text-align:${v}`);
        if (k === "color") rules.push(`color:${v}`);
        if (k === "size") rules.push(`font-size:${v}px`);
        if (k === "weight") rules.push(`font-weight:${v}`);
        if (k === "font") rules.push(`font-family:${v}`);
      }
      css.push(`.${className} { ${rules.join("; ")} }`);
    }

    if (className) attrs.push(`class="${className}"`);

    if (entry.type === "self") {
      html.push(`<${entry.tag}${attrs.length ? " " + attrs.join(" ") : ""}>`);
    } else {
      html.push(`<${entry.tag}${attrs.length ? " " + attrs.join(" ") : ""}>${text}`);
      stack.push(entry.tag);
    }
  }

  while (stack.length) {
    html.push(`</${stack.pop()}>`);
  }

  lastHTML = html.join("\n");
  lastCSS = css.join("\n") || "/* no styles */";

  htmlOut.textContent = lastHTML;
  cssOut.textContent = lastCSS;
}


/* ============================
   ZENITH V1 — PREVIEW
=============================== */

function previewZenith() {
  if (!lastHTML) compileZenith();

  const bodyMatch = lastHTML.match(/<body[^>]*>([\s\S]*)<\/body>/);
  const body = bodyMatch ? bodyMatch[1] : lastHTML;

  preview.srcdoc = `
<!DOCTYPE html>
<html>
<head>
<style>
${lastCSS}
</style>
</head>
<body>
${body}
</body>
</html>
`;
}